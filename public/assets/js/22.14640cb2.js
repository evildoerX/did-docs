(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{210:function(D,t,r){"use strict";r.r(t);var _=r(4),e=Object(_.a)({},function(){var D=this,t=D.$createElement,r=D._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":D.$parent.slotKey}},[r("h1",{attrs:{id:"_9-安全考虑因素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-安全考虑因素","aria-hidden":"true"}},[D._v("#")]),D._v(" 9. 安全考虑因素")]),D._v(" "),r("blockquote",[r("p",[D._v("本节不具有规范性。")])]),D._v(" "),r("p",[r("strong",[D._v("注意事项：")]),D._v("\n在实施者的草案阶段，本节重点介绍在早期实施中应该重要的安全主题。编辑们也在寻求有关威胁和威胁缓解的反馈，这些反馈应该反映在本节或规范的其他部分。由于根标识符记录了分布式身份标识符，因此DID和DID文档是分散式身份管理的重要组成部分。它们也是DPKI（分散式公钥基础设施）的基础构建块，作为传统X.509证书的增强。因此，DID被设计为在许多IETF标准使用的通用因特网威胁模型下操作。我们假设不妥协的端点，但允许在网络上读取或损坏消息。在系统受到危害时防止攻击需要外部密钥签名硬件。有关密钥撤销和恢复的信息，请参见"),r("a",{attrs:{href:""}},[D._v("§ 9.8 Key Revocation and Recovery ")]),D._v("部分。对于托管DID和DID文档的DLT，它们具有防止主动攻击的特殊安全属性。他们的设计使用公钥/私钥密码术，允许在被动监控的网络上运行，而不会有私钥泄露的风险。这使得DID架构和分散身份成为可能。")]),D._v(" "),r("h2",{attrs:{id:"_9-1-did方法规范的要求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-did方法规范的要求","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.1 DID方法规范的要求")]),D._v(" "),r("ol",[r("li",[D._v("DID方法规范必须包含自己的安全注意事项部分。")]),D._v(" "),r("li",[D._v("本节必须考虑[RFC3552]（第27页）第5节中提到的规范中定义的DID操作的所有要求。特别是：")])]),D._v(" "),r("div",{staticClass:"danger custom-block"},[r("p",[D._v("重新启动Web of Trust 5的讨论促成了将授权转移到DID方法规范的共识。目前预计会尝试创建基于对象功能的通用授权机制。")])]),D._v(" "),r("p",[D._v("至少必须考虑以下形式的攻击：窃听，重放，消息插入，删除，修改和中间人。还必须识别潜在的拒绝服务攻击。如果协议包含加密保护机制，则应清楚地指出数据的哪些部分受到保护以及保护是什么（即，仅完整性，机密性和/或端点认证等）。还应该指出加密保护容易受到什么样的攻击。应该保密的数据（密钥材料，随机种子等）应该清楚标明。如果该技术涉及认证，特别是用户主机认证，则必须明确指定认证方法的安全性。")]),D._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[D._v("根据[RFC3552]的第5节，本节还必须讨论在部署威胁缓解后的剩余风险（例如相关协议中的妥协风险，不正确的实施或密码）。")]),D._v(" "),r("li",[D._v("本节必须为本规范第7节（DID操作）所要求的所有操作提供完整性保护和更新认证。")]),D._v(" "),r("li",[D._v("在DID方法利用对等计算资源（例如所有已知的DLT）的情况下，应该讨论这些资源的预期负担与拒绝服务有关。")]),D._v(" "),r("li",[D._v("必须讨论特定于方法的端点认证。其中DID方法使用具有不同网络拓扑的DLT，有时提供为“light node”或“ thin client ”,在减少所需计算资源的实现中，必须讨论可用于DID方法实现的拓扑的安全假设。")]),D._v(" "),r("li",[D._v("DID方法必须讨论证明DID被唯一分配的策略机制。 DID符合"),r("router-link",{attrs:{to:"/dids/References.html#rfc8141"}},[D._v("RFC8141")]),D._v("中定义的URN的功能定义 - 一个永久标识符，该标识符一次分配给资源并且从不重新分配。在安全上下文中，这尤其重要，因为DID可用于标识受特定授权权限集限制的特定方。\n8.引入新的身份验证服务端点类型的DID方法（"),r("router-link",{attrs:{to:"/guide/DIDDocuments.html#_5-6-service-endpoints"}},[D._v("第5.6节服务端点")]),D._v("）应该考虑支持的身份验证协议的安全要求。")],1)]),D._v(" "),r("h2",{attrs:{id:"_9-2-选择-did-resolvers"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-选择-did-resolvers","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.2 选择 DID Resolvers")]),D._v(" "),r("p",[r("router-link",{attrs:{to:"/dids/References.html#did-method-registry"}},[D._v("DID-METHOD-REGISTRY")]),D._v("是DID方法名称及其相应的DID方法规范的信息列表。实现者应该记住，没有中央权限来强制要求哪个DID方法规范必须与任何特定(的DID方法名称一起使用，但是在选择"),r("router-link",{attrs:{to:"/guide/Resolvers.html"}},[D._v("§8。DID Resolvers")]),D._v("实现时，可以使用"),r("router-link",{attrs:{to:"/dids/References.html#did-method-registry"}},[D._v("DID-METHOD-REGISTRY")]),D._v(")做出明智的决定。")],1),D._v(" "),r("h2",{attrs:{id:"_9-3-绑定身份"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-绑定身份","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.3 绑定身份")]),D._v(" "),r("h3",{attrs:{id:"_9-3-1-证明控制did和did-document"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-1-证明控制did和did-document","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.3.1 证明控制DID和DID Document")]),D._v(" "),r("p",[D._v("签名是允许DID文档以加密方式验证的一种方法。")]),D._v(" "),r("p",[D._v("就其本身而言，自签名DID文档上的经过验证的签名不能证明对DID的控制。它只证明了以下内容：")]),D._v(" "),r("ol",[r("li",[D._v("DID文档自注册以来未被篡改。")]),D._v(" "),r("li",[D._v("DID文档的控制器在生成签名时控制用于签名的私钥。")])]),D._v(" "),r("p",[D._v("证明对DID的控制，即DID与描述它的DID文档之间的绑定，需要两个步骤：")]),D._v(" "),r("ol",[r("li",[D._v("根据DID方法规范将DID解析为DID文档。")]),D._v(" "),r("li",[D._v("验证生成的DID文档的id属性是否与已解析的DID匹配。")])]),D._v(" "),r("p",[D._v("应该注意的是，无论DID文档是否签名，此过程都证明了对DID和DID文档的控制。")]),D._v(" "),r("p",[D._v("DID文档上的签名是可选的。DID方法规范应该 解释并指定它们的实现（如果适用）。")]),D._v(" "),r("p",[D._v("它被推荐到时间戳与签名相结合。")]),D._v(" "),r("h3",{attrs:{id:"_9-3-2-证明公钥的控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-2-证明公钥的控制","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.3.2 证明公钥的控制")]),D._v(" "),r("p",[D._v("有两种方法可以证明控制与DID文档中的公钥描述相对应的私钥：静态和动态。静态方法是使用私钥对DID文档进行签名。这证明在不晚于DID文档注册的时间控制私钥。如果DID文档未签名，则仍可以动态证明对DID文档中描述的公钥的控制如下：")]),D._v(" "),r("ol",[r("li",[D._v("将包含公钥描述的质询消息从DID文档和随机数发送到DID文档中描述的适当服务端点。")]),D._v(" "),r("li",[D._v("根据公钥描述验证响应消息的签名。")])]),D._v(" "),r("h3",{attrs:{id:"_9-3-3-身份验证和可验证的声明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-3-身份验证和可验证的声明","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.3.3 身份验证和可验证的声明")]),D._v(" "),r("p",[D._v("DID和DID文档本身不携带任何 PII（个人身份信息）。将DID绑定到现实世界中的某些事物（例如个人或公司）的过程（例如，具有与该DID相同的主题的凭证）超出了本规范的范围。然而，该主题是 W3C（“DID”一词起源）的可验证声明标准化工作的重点 。")]),D._v(" "),r("h2",{attrs:{id:"_9-4-身份验证服务端点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-身份验证服务端点","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.4 身份验证服务端点")]),D._v(" "),r("p",[D._v("如果DID文档发布用于身份验证或授权的服务端点（第 §节） 5.6 服务端点 ），服务端点提供者，主体和/或依赖方有责任遵守该服务端点支持的认证协议的要求。")]),D._v(" "),r("h2",{attrs:{id:"_9-5-不可否认"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-不可否认","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.5 不可否认")]),D._v(" "),r("p",[D._v("DID和DID文档更新的不可否认性得到以下假设的支持：（1）主体正在监控未经授权的更新（参见章节§ 9.6 DID文档更改通知 ）和（2）主题有足够的机会根据DID方法的访问控制机制恢复恶意更新（部分 § 5.4 身份验证 ）。如果包含时间戳，则进一步支持此功能（部分 § 5.7 创建（可选） 和§ 5.8 更新（可选） ）和目标DLT系统支持时间戳。")]),D._v(" "),r("h2",{attrs:{id:"_9-6-did文档更改通知"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-6-did文档更改通知","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.6 DID文档更改通知")]),D._v(" "),r("p",[D._v("防止对DID文档进行未经授权的更改的一种缓解措施是监控并在发生更改时主动通知主题。这类似于通过向文件中的电子邮件地址发送密码重置通知来帮助防止对传统用户名/密码帐户的帐户接管。对于DID，如果没有中间注册商或帐户提供商生成通知，建议采用以下方法：")]),D._v(" "),r("ol",[r("li",[D._v("订阅。如果注册了DID 的"),r("a",{attrs:{href:"https://w3c-ccg.github.io/did-spec/#dfn-dir",target:"_blank",rel:"noopener noreferrer"}},[D._v(" Decentralized Identifier Registry -分布式身份标识符注册表"),r("OutboundLink")],1),D._v("直接支持更改通知，则可以向DID控制器提供此服务。通知可以直接发送到现有DID中列出的相关服务端点。")]),D._v(" "),r("li",[D._v("自我监控。DID主题可以使用他们自己的本地或在线代理来定期监视DID文档的更改。")]),D._v(" "),r("li",[D._v("第三方监控。DID主题可能依赖于第三方监控服务，但是这引入了另一种攻击向量。")])]),D._v(" "),r("h2",{attrs:{id:"_9-7-密钥和签名到期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-7-密钥和签名到期","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.7 密钥和签名到期")]),D._v(" "),r("p",[D._v("在分散式标识符体系结构中，没有集中式权限来强制实施密钥或签名过期策略。因此，DID解析器和其他客户端应用程序应该验证密钥在使用时是否已过期。由于某些用例可能有正当理由可以扩展已经过期的密钥，因此密钥过期不应该阻止密钥的进一步使用，并且解析器的实现应该与这种扩展行为兼容。")]),D._v(" "),r("h2",{attrs:{id:"_9-8-关键撤销和恢复"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-8-关键撤销和恢复","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.8 关键撤销和恢复")]),D._v(" "),r("p",[D._v("第§节 7.2 DID操作 指定DID方法规范必须支持的DID操作，包括通过将DID文档替换为更新的DID文档来取消激活DID文档。通常，检查基于DLT的方法的密钥撤销是否会以类似于检查分布式分类帐上的加密货币帐户余额的方式处理：如果余额为空，则停用整个DID。DID方法规范应该应该支持法定数量的可信方以启用密钥恢复。第6.5节“授权”中建议了一些这样做的设施。请注意，并非所有的DID方法规范将识别控制使用其他DID方法和他们的DID注册MAY将第三方控件限制为使用相同方法的DID。访问控制，并在DID方法规范键恢复可能还包括一个时间锁功能，防止密钥泄露通过保持恢复控制的第二轨道。此类控制的进一步说明是未来工作的问题（参见§ 部分）11.4 时间锁和DID文件恢复 ）。")]),D._v(" "),r("h2",{attrs:{id:"_9-9-人类友好标识符的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-9-人类友好标识符的作用","aria-hidden":"true"}},[D._v("#")]),D._v(" 9.9 人类友好标识符的作用")]),D._v(" "),r("p",[D._v("DID实现全球唯一性，无需中央注册机构。然而，这是以人类可记忆性为代价的。能够生成全局唯一标识符的算法自动生成没有人类意义的随机字符串。这证明了关于被称为Zooko三角形的标识符的公理：“人类有意义，分散，安全挑选任何两个”。")]),D._v(" "),r("p",[D._v("当然有许多用例需要在从人性友好标识符开始时发现DID - 自然语言名称，域名或DID控制器的常规地址，例如移动电话号码，电子邮件地址，Twitter句柄或博客URL。但是，将人性化标识符映射到DID（并且以可以验证和信任的方式这样做）的问题超出了本规范的范围。")]),D._v(" "),r("p",[D._v("这个问题的解决方案（有很多）应该在引用本规范的单独规范中定义。强烈建议此类规范仔细考虑：（a）基于欺骗用户关于目标实体的真正人类友好标识符的众多安全攻击，以及（b）使用本质上相关的人类友好标识符的隐私后果，特别是如果它们是全球唯一的。")])])},[],!1,null,null,null);t.default=e.exports}}]);